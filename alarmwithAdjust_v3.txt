
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_12_4(

	//////////// CLOCK //////////
input           MAX10_CLK1_50,

//////////// SEG7 //////////
output     [7:0] HEX0,
output     [7:0] HEX1,
output     [7:0] HEX2,
output     [7:0] HEX3,
output     [7:0] HEX4,
output     [7:0] HEX5,

//////////// KEY //////////
input     [1:0] KEY,

//////////// LED //////////
output     [9:0] LEDR,

//////////// SW //////////
input     [9:0] SW
);


// ========================================================
// CLOCK and RESET

assign reset = ~KEY[1];
assign clock = MAX10_CLK1_50;
//assign clock = ~KEY[0];

// ========================================================
// REGISTERS ARE LIKE GLOBAL VARIABLES !

// en is a modulo 50_000_000 counter
reg  [27-1:0] en_Q;
wire [27-1:0] en_D;

// dec0 and dec1 are BCD format decimal digits for SECONDS
// dec2 and dec3 are BCD format decimal digits for MINUTES
// dec3 and dec4 are BCD format decimal digits for HOURS

reg  [4-1:0] dec0_Q, dec1_Q, dec2_Q, dec3_Q, dec4_Q, dec5_Q;
wire [4-1:0] dec0_D, dec1_D, dec2_D, dec3_D, dec4_D, dec5_D;

reg  [4-1:0] AlarmDec0_Q, AlarmDec1_Q, AlarmDec2_Q, AlarmDec3_Q, AlarmDec4_Q, AlarmDec5_Q;
wire [4-1:0] AlarmDec0_D, AlarmDec1_D, AlarmDec2_D, AlarmDec3_D, AlarmDec4_D, AlarmDec5_D;

wire alarm_set_mode;

assign alarm_set_mode = SW[3];

reg inc_key_Q;
wire inc_key_D;
wire inc_key_level;
wire inc_Pulse;

assign inc_key_level = ~KEY[0];
assign inc_pulse = inc_key_level && ~inc_key_Q;
assign inc_key_D = inc_key_level;

always @(posedge clock)
begin
if (reset)
begin
AlarmDec0_Q <= 0;
AlarmDec1_Q <= 0;
AlarmDec2_Q <= 0;
AlarmDec3_Q <= 0;
AlarmDec4_Q <= 8;
AlarmDec5_Q <= 0;
en_Q   <= 0;
dec0_Q <= 0;
dec1_Q <= 0;
dec2_Q <= 0;
dec3_Q <= 0;
dec4_Q <= 0;
dec5_Q <= 0;
inc_key_Q <= 0;
end
else
begin
AlarmDec0_Q <= AlarmDec0_D;
AlarmDec1_Q <= AlarmDec1_D;
AlarmDec2_Q <= AlarmDec2_D;
AlarmDec3_Q <= AlarmDec3_D;
AlarmDec4_Q <= AlarmDec4_D;
AlarmDec5_Q <= AlarmDec5_D;
en_Q   <= en_D;
dec0_Q <= dec0_D;
dec1_Q <= dec1_D;
dec2_Q <= dec2_D;
dec3_Q <= dec3_D;
dec4_Q <= dec4_D;
dec5_Q <= dec5_D;
inc_key_Q <= inc_key_D;
end
end

assign en_D = tick ? 0: en_Q + 1;
assign tick1 = (en_Q == 50_000_000 - 1); // Will be equal to 1 once in a second
assign tickX = (en_Q >= {2'b0, SW[8:0], ~(16'b0)} -1); // Fast tick period = 20 ns * (2^16 * SW[8:0] + 16'hFFFF)
assign tick  = SW[9] ? tick1 : tickX; // Fast tick or regular tick select using SW[9]
//assign tick = ~KEY[0];

wire sel_sec;
wire sel_min;
wire sel_hour;
wire inc_key;
wire adjust_active;

assign sel_sec  = SW[0];
assign sel_min  = SW[1];
assign sel_hour = SW[2];
assign adjust_active = (sel_sec || sel_min || sel_hour) && ~alarm_set_mode;  // 1 when any adjust switch is on

assign dec0_D = (!adjust_active && tick)?(dec0_Q == 9 ? 0 : dec0_Q + 1):
				((sel_sec && inc_pulse && ~alarm_set_mode)? (dec0_Q == 9 ? 0 : dec0_Q + 1) :dec0_Q);

assign AlarmDec0_D = alarm_set_mode ? ((sel_sec && inc_pulse)? (AlarmDec0_Q == 9 ? 0 : AlarmDec0_Q + 1) :AlarmDec0_Q) : AlarmDec0_Q;

//--------------------------------------------
// SECOND TENS
//--------------------------------------------
assign dec1_D = (!adjust_active && tick && (dec0_Q == 9)) ? 
			(dec1_Q == 5 ? 0 : dec1_Q + 1) : 
			((sel_sec && inc_pulse && ~alarm_set_mode && (dec0_Q == 9)) ? (dec1_Q == 5 ? 0 : dec1_Q + 1) :dec1_Q);

assign AlarmDec1_D = alarm_set_mode ? ((sel_sec && inc_pulse && (AlarmDec0_Q == 9)) ? (AlarmDec1_Q == 5 ? 0 : AlarmDec1_Q + 1) :AlarmDec1_Q) : AlarmDec1_Q;


//--------------------------------------------
// MINUTE ONES
//--------------------------------------------
assign dec2_D = (!adjust_active && tick && (dec0_Q == 9) && (dec1_Q == 5)) ? 
		(dec2_Q == 9 ? 0 : dec2_Q + 1) :
		(sel_min && inc_pulse && ~alarm_set_mode) ? (dec2_Q == 9 ? 0 : dec2_Q + 1) :dec2_Q;

assign AlarmDec2_D = alarm_set_mode ? ((sel_min && inc_pulse) ? (AlarmDec2_Q == 9 ? 0 : AlarmDec2_Q + 1) :AlarmDec2_Q) : AlarmDec2_Q;

//--------------------------------------------
// MINUTE TENS
//--------------------------------------------
assign dec3_D = (!adjust_active && tick && (dec0_Q == 9) && (dec1_Q == 5) && (dec2_Q == 9)) ? 
		(dec3_Q == 5 ? 0 : dec3_Q + 1) : (sel_min && inc_pulse && ~alarm_set_mode && (dec2_Q == 9)) ? 
		(dec3_Q == 5 ? 0 : dec3_Q + 1) :
		dec3_Q;
		
assign AlarmDec3_D = alarm_set_mode ? ((sel_min && inc_pulse && (AlarmDec2_Q == 9)) ? 
		(AlarmDec3_Q == 5 ? 0 : AlarmDec3_Q + 1) : AlarmDec3_Q) : AlarmDec3_Q;

//--------------------------------------------
// HOUR ONES
//--------------------------------------------
assign dec4_D = (!adjust_active && tick && (dec0_Q == 9) && (dec1_Q == 5) &&
		(dec2_Q == 9) && (dec3_Q == 5)) ? ((dec5_Q == 2 && dec4_Q == 3) ? 0 :
		(dec4_Q == 9 ? 0 : dec4_Q + 1)) : (sel_hour && inc_pulse && ~alarm_set_mode) ? 
		((dec5_Q == 2 && dec4_Q == 3) ? 0 :(dec4_Q == 9 ? 0 : dec4_Q + 1)) : dec4_Q;

assign AlarmDec4_D = alarm_set_mode ? ((sel_hour && inc_pulse) ? 
		((AlarmDec5_Q == 2 && AlarmDec4_Q == 3) ? 0 : ((AlarmDec5_Q == 1 && AlarmDec4_Q == 9) ? 0 : (AlarmDec4_Q == 9 ? 0 : AlarmDec4_Q + 1))) : AlarmDec4_Q) : AlarmDec4_Q;		


//--------------------------------------------
// HOUR TENS
//--------------------------------------------
assign dec5_D = (!adjust_active && tick && (dec0_Q == 9) && (dec1_Q == 5) &&
		(dec2_Q == 9) && (dec3_Q == 5) && (dec4_Q == 9 || (dec5_Q == 2 && dec4_Q == 3))) ?
		(dec5_Q == 2 ? 0 : dec5_Q + 1) : (sel_hour && inc_pulse && ~alarm_set_mode && (dec4_Q == 9 || (dec5_Q == 2 && dec4_Q == 3))) ?
      (dec5_Q == 2 ? 0 : dec5_Q + 1) : dec5_Q;

assign AlarmDec5_D = alarm_set_mode ? ((sel_hour && inc_pulse && (AlarmDec4_Q == 9 || (AlarmDec5_Q == 2 && AlarmDec4_Q == 3))) ? 
		(AlarmDec5_Q == 2 ? 0 : AlarmDec5_Q + 1) : AlarmDec5_Q) : AlarmDec5_Q;

// ========================================================
// OUTPUT LOGIC
//--------------------------------------------------------
// ALARM CONDITION (example: 12:45:00)
//--------------------------------------------------------
wire alarm;
assign alarm =
    (dec5_Q == AlarmDec5_Q) &&
    (dec4_Q == AlarmDec4_Q) &&
    (dec3_Q == AlarmDec3_Q) &&
    (dec2_Q == AlarmDec2_Q) &&
	 (dec1_Q == AlarmDec1_Q) &&
    (dec0_Q == AlarmDec0_Q);
		// when time rolls into 8:00:00

//--------------------------------------------------------
// LATCH ALARM UNTIL KEY0 PRESSED
//--------------------------------------------------------
reg alarm_latch;
reg [5:0] alarm_timer;

always @(posedge clock or posedge reset)
begin
if (reset) begin
	alarm_latch <= 0;
	alarm_timer <= 0;
end
else if (~KEY[0]) begin      // press KEY0 to clear alarm
	alarm_latch <= 0;
	alarm_timer <= 0;
end
else if (alarm) begin       // alarm fires once per event
	alarm_latch <= 1;
	alarm_timer <= 20;
end
else if (alarm_latch && tick1) begin
if (alarm_timer > 0)
	alarm_timer <= alarm_timer -1;
else
	alarm_latch <= 0;
end
end

//--------------------------------------------------------
// BLINK GENERATOR (1 Hz from tick1)
//--------------------------------------------------------
reg blink;

always @(posedge clock or posedge reset)
begin
    if (reset)
        blink <= 0;
    else if (tick1)        // tick1 = 1-second strobe
        blink <= ~blink;
end


//--------------------------------------------------------
// LED FLASH OUTPUT (replace old LEDR assignments)
//--------------------------------------------------------
assign LEDR = alarm_latch ? {10{blink}} : 10'b0;



// Internal segment wires
wire [6:0] seg0, seg1, seg2, seg3, seg4, seg5;
wire [3:0] disp0, disp1, disp2, disp3, disp4, disp5;

assign disp0 = alarm_set_mode ? AlarmDec0_Q : dec0_Q;
assign disp1 = alarm_set_mode ? AlarmDec1_Q : dec1_Q;
assign disp2 = alarm_set_mode ? AlarmDec2_Q : dec2_Q;
assign disp3 = alarm_set_mode ? AlarmDec3_Q : dec3_Q;
assign disp4 = alarm_set_mode ? AlarmDec4_Q : dec4_Q;
assign disp5 = alarm_set_mode ? AlarmDec5_Q : dec5_Q;

// Hook up decoders (active-high output)
Seg U0(.hex(disp0), .seg(seg0));
Seg U1(.hex(disp1), .seg(seg1));
Seg U2(.hex(disp2), .seg(seg2));
Seg U3(.hex(disp3), .seg(seg3));
Seg U4(.hex(disp4), .seg(seg4));
Seg U5(.hex(disp5), .seg(seg5));

// Assign to HEX display (active-LOW on MAX10 board)
assign HEX0 = {1'b0, ~seg0};
assign HEX1 = {1'b0, ~seg1};
assign HEX2 = {1'b0, ~seg2};
assign HEX3 = {1'b0, ~seg3};
assign HEX4 = {1'b0, ~seg4};
assign HEX5 = {1'b0, ~seg5};


endmodule


